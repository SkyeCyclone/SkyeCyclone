From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <marshallofsound@electronjs.org>
Date: Mon, 6 Jul 2020 16:58:29 -0700
Subject: chore: add crashpad patches for apple silicon

These will appear upstream shortly and when they do we can remove this patch.

diff --git a/base/process/process_metrics_mac.cc b/base/process/process_metrics_mac.cc
index 33b10d8563f0f9dc7bea1478664b075658378b2f..25b7579aec3953f57528acdd1ce738cc15bb1e26 100644
--- a/base/process/process_metrics_mac.cc
+++ b/base/process/process_metrics_mac.cc
@@ -28,7 +28,7 @@ namespace {
 // This is a standin for the private pm_task_energy_data_t struct.
 struct OpaquePMTaskEnergyData {
   // Empirical size of the private struct.
-  uint8_t data[384];
+  uint8_t data[408];
 };
 
 // Sample everything but network usage, since fetching network
@@ -300,7 +300,6 @@ bool GetSystemMemoryInfo(SystemMemoryInfoKB* meminfo) {
   }
   DCHECK_EQ(HOST_VM_INFO64_COUNT, count);
 
-  static_assert(PAGE_SIZE % 1024 == 0, "Invalid page size");
   meminfo->free = saturated_cast<int>(
       PAGE_SIZE / 1024 * (vm_info.free_count - vm_info.speculative_count));
   meminfo->speculative =
diff --git a/base/profiler/native_unwinder_mac.cc b/base/profiler/native_unwinder_mac.cc
index 48232c5d0ce244d6e9a53e0d2229ec162e94c31a..d31c3d09700fd321fca0620785928075e5dfd50a 100644
--- a/base/profiler/native_unwinder_mac.cc
+++ b/base/profiler/native_unwinder_mac.cc
@@ -15,9 +15,11 @@
 #include "base/profiler/native_unwinder.h"
 #include "base/profiler/profile_builder.h"
 
+#if defined(ARCH_CPU_X86_64)
 extern "C" {
 void _sigtramp(int, int, struct sigset*);
 }
+#endif
 
 namespace base {
 
@@ -103,6 +105,7 @@ const ModuleCache::Module* GetLibSystemKernelModule(ModuleCache* module_cache) {
   return module;
 }
 
+#if defined(ARCH_CPU_X86_64)
 void GetSigtrampRange(uintptr_t* start, uintptr_t* end) {
   auto address = reinterpret_cast<uintptr_t>(&_sigtramp);
   DCHECK(address != 0);
@@ -123,22 +126,33 @@ void GetSigtrampRange(uintptr_t* start, uintptr_t* end) {
   DCHECK_EQ(info.start_ip, address);
   *end = info.end_ip;
 }
+#endif
 
 }  // namespace
 
 NativeUnwinderMac::NativeUnwinderMac(ModuleCache* module_cache)
     : libsystem_kernel_module_(GetLibSystemKernelModule(module_cache)) {
+#if defined(ARCH_CPU_X86_64)
   GetSigtrampRange(&sigtramp_start_, &sigtramp_end_);
+#endif
 }
 
 bool NativeUnwinderMac::CanUnwindFrom(const Frame& current_frame) const {
+#if defined(ARCH_CPU_ARM64)
+  return false;
+#else
   return current_frame.module && current_frame.module->IsNative();
+#endif
 }
 
 UnwindResult NativeUnwinderMac::TryUnwind(RegisterContext* thread_context,
                                           uintptr_t stack_top,
                                           ModuleCache* module_cache,
                                           std::vector<Frame>* stack) const {
+#if defined(ARCH_CPU_ARM64)
+  return UnwindResult::ABORTED;
+#endif
+
   // We expect the frame correponding to the |thread_context| register state to
   // exist within |stack|.
   DCHECK_GT(stack->size(), 0u);
@@ -187,11 +201,16 @@ UnwindResult NativeUnwinderMac::TryUnwind(RegisterContext* thread_context,
       stack->emplace_back(rip, module_cache->GetModuleForAddress(rip));
 
       // Save the relevant register state back into the thread context.
+#if defined(ARCH_CPU_ARM64)
+      RegisterContextSetInstructionPointer(thread_context, rip);
+      RegisterContextSetStackPointer(thread_context, rsp);
+#else
       unw_word_t rbp;
       unw_get_reg(&unwind_cursor, UNW_X86_64_RBP, &rbp);
       thread_context->__rip = rip;
       thread_context->__rsp = rsp;
       thread_context->__rbp = rbp;
+#endif
     }
 
     if (result.has_value())
@@ -233,6 +252,7 @@ Optional<UnwindResult> NativeUnwinderMac::CheckPreconditions(
     return UnwindResult::UNRECOGNIZED_FRAME;
   }
 
+#if defined(ARCH_CPU_X86_64)
   // Don't continue if we're in sigtramp. Unwinding this from another thread
   // is very fragile. It's a complex DWARF unwind that needs to restore the
   // entire thread context which was saved by the kernel when the interrupt
@@ -241,6 +261,7 @@ Optional<UnwindResult> NativeUnwinderMac::CheckPreconditions(
       current_frame->instruction_pointer < sigtramp_end_) {
     return UnwindResult::ABORTED;
   }
+#endif
 
   // Don't continue if rbp appears to be invalid (due to a previous bad
   // unwind).
diff --git a/base/profiler/native_unwinder_mac.h b/base/profiler/native_unwinder_mac.h
index 1fcd76358dfd359203aac09c43755b8b195bce96..40c478b83c87355f8279ad60b1b7151c88973477 100644
--- a/base/profiler/native_unwinder_mac.h
+++ b/base/profiler/native_unwinder_mac.h
@@ -48,9 +48,11 @@ class NativeUnwinderMac : public Unwinder {
   // Cached pointer to the libsystem_kernel module.
   const ModuleCache::Module* const libsystem_kernel_module_;
 
+#if defined(ARCH_CPU_X86_64)
   // The address range of |_sigtramp|, the signal trampoline function.
   uintptr_t sigtramp_start_;
   uintptr_t sigtramp_end_;
+#endif
 };
 
 }  // namespace base
diff --git a/base/profiler/register_context.h b/base/profiler/register_context.h
index 5e4a82bdc612325d11455d4f6c42fa83c2d6b25a..a27925a33fc3422426796f61e50eceed5ef0e3c8 100644
--- a/base/profiler/register_context.h
+++ b/base/profiler/register_context.h
@@ -93,20 +93,30 @@ inline uintptr_t& RegisterContextInstructionPointer(
 
 #elif defined(ARCH_CPU_ARM64)
 
-// TODO(thakis): Have getter/setter functions instead of returning a ref to
-// prepare for arm64e. See __DARWIN_OPAQUE_ARM_THREAD_STATE6 in
-// mach/arm/_structs.h
-inline uintptr_t& RegisterContextStackPointer(arm_thread_state64_t* context) {
-  return AsUintPtr(&context->__sp);
+inline uintptr_t RegisterContextStackPointer(arm_thread_state64_t* context) {
+  return arm_thread_state64_get_sp(*context);
 }
 
-inline uintptr_t& RegisterContextFramePointer(arm_thread_state64_t* context) {
-  return AsUintPtr(&context->__fp);
+inline uintptr_t RegisterContextFramePointer(arm_thread_state64_t* context) {
+  return arm_thread_state64_get_fp(*context);
 }
 
-inline uintptr_t& RegisterContextInstructionPointer(
+inline uintptr_t RegisterContextInstructionPointer(
     arm_thread_state64_t* context) {
-  return AsUintPtr(&context->__pc);
+  return arm_thread_state64_get_pc(*context);
+}
+
+inline void RegisterContextSetStackPointer(arm_thread_state64_t* context, uintptr_t sp) {
+  arm_thread_state64_set_sp(*context, sp);
+}
+
+inline void RegisterContextSetFramePointer(arm_thread_state64_t* context, uintptr_t fp) {
+  arm_thread_state64_set_fp(*context, fp);
+}
+
+inline void RegisterContextSetInstructionPointer(
+    arm_thread_state64_t* context, uintptr_t ip) {
+  arm_thread_state64_set_pc_fptr(*context, reinterpret_cast<void*>(ip));
 }
 #endif
 
diff --git a/base/profiler/stack_sampler_impl_unittest.cc b/base/profiler/stack_sampler_impl_unittest.cc
index 48b12c299ec8cbbba6b98b4f9f0605d5a97cd16e..e0111fb4454c5a4c8c5546ccc93c26f905ada9fa 100644
--- a/base/profiler/stack_sampler_impl_unittest.cc
+++ b/base/profiler/stack_sampler_impl_unittest.cc
@@ -22,6 +22,9 @@
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
+// FIXME: Reenable for arm64.
+#if !defined(ARCH_CPU_ARM64)
+
 namespace base {
 
 namespace {
@@ -501,3 +504,5 @@ TEST(StackSamplerImplTest, WalkStack_NativeThenAux) {
 }
 
 }  // namespace base
+
+#endif
diff --git a/base/profiler/suspendable_thread_delegate_mac.cc b/base/profiler/suspendable_thread_delegate_mac.cc
index a31a0caf2b15cca0ebff7e19e5906d119f319f66..f1e006a4e6ac458cab32837412958c6dd8d113ee 100644
--- a/base/profiler/suspendable_thread_delegate_mac.cc
+++ b/base/profiler/suspendable_thread_delegate_mac.cc
@@ -24,11 +24,18 @@ namespace base {
 namespace {
 
 // Fills |state| with |target_thread|'s context. NO HEAP ALLOCATIONS.
-bool GetThreadState(thread_act_t target_thread, x86_thread_state64_t* state) {
+bool GetThreadState(thread_act_t target_thread, RegisterContext* state) {
+#if defined(ARCH_CPU_X86_64)
   auto count = static_cast<mach_msg_type_number_t>(x86_THREAD_STATE64_COUNT);
   return thread_get_state(target_thread, x86_THREAD_STATE64,
                           reinterpret_cast<thread_state_t>(state),
                           &count) == KERN_SUCCESS;
+#elif defined(ARCH_CPU_ARM64)
+  auto count = static_cast<mach_msg_type_number_t>(ARM_THREAD_STATE64_COUNT);
+  return thread_get_state(target_thread, ARM_THREAD_STATE64,
+                          reinterpret_cast<thread_state_t>(state),
+                          &count) == KERN_SUCCESS;
+#endif
 }
 
 }  // namespace
@@ -68,7 +75,7 @@ SuspendableThreadDelegateMac::SuspendableThreadDelegateMac(
   // Therefore, for all the system functions that might be linked in dynamically
   // that are used while threads are suspended, make calls to them to make sure
   // that they are linked up.
-  x86_thread_state64_t thread_state;
+  RegisterContext thread_state;
   GetThreadState(thread_port_, &thread_state);
 }
 
@@ -85,7 +92,7 @@ PlatformThreadId SuspendableThreadDelegateMac::GetThreadId() const {
 
 // NO HEAP ALLOCATIONS.
 bool SuspendableThreadDelegateMac::GetThreadContext(
-    x86_thread_state64_t* thread_context) {
+    RegisterContext* thread_context) {
   return GetThreadState(thread_port_, thread_context);
 }
 
@@ -100,12 +107,17 @@ bool SuspendableThreadDelegateMac::CanCopyStack(uintptr_t stack_pointer) {
 }
 
 std::vector<uintptr_t*> SuspendableThreadDelegateMac::GetRegistersToRewrite(
-    x86_thread_state64_t* thread_context) {
+    RegisterContext* thread_context) {
+#if defined(ARCH_CPU_X86_64)
   return {
       &AsUintPtr(&thread_context->__rbx), &AsUintPtr(&thread_context->__rbp),
       &AsUintPtr(&thread_context->__rsp), &AsUintPtr(&thread_context->__r12),
       &AsUintPtr(&thread_context->__r13), &AsUintPtr(&thread_context->__r14),
       &AsUintPtr(&thread_context->__r15)};
+#elif defined(ARCH_CPU_ARM64)
+  // FIXME: Should return x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, fp, and lr.
+  return { };
+#endif
 }
 
 }  // namespace base
diff --git a/base/profiler/suspendable_thread_delegate_mac.h b/base/profiler/suspendable_thread_delegate_mac.h
index f6eee8fe1434acf09b856a152bdb7b5bb4454030..1898b377a9c8ce1085c0381d34c74812d23ed3b3 100644
--- a/base/profiler/suspendable_thread_delegate_mac.h
+++ b/base/profiler/suspendable_thread_delegate_mac.h
@@ -46,12 +46,12 @@ class BASE_EXPORT SuspendableThreadDelegateMac
   // SuspendableThreadDelegate
   std::unique_ptr<SuspendableThreadDelegate::ScopedSuspendThread>
   CreateScopedSuspendThread() override;
-  bool GetThreadContext(x86_thread_state64_t* thread_context) override;
+  bool GetThreadContext(RegisterContext* thread_context) override;
   PlatformThreadId GetThreadId() const override;
   uintptr_t GetStackBaseAddress() const override;
   bool CanCopyStack(uintptr_t stack_pointer) override;
   std::vector<uintptr_t*> GetRegistersToRewrite(
-      x86_thread_state64_t* thread_context) override;
+      RegisterContext* thread_context) override;
 
  private:
   // Weak reference: Mach port for thread being profiled.
diff --git a/third_party/crashpad/crashpad/client/simulate_crash_mac.cc b/third_party/crashpad/crashpad/client/simulate_crash_mac.cc
index 8d6e8bd9286f50db96d45c39e3359acc446dc94b..87ba479ec3c0610735efe221f77e60a1a344ad6f 100644
--- a/third_party/crashpad/crashpad/client/simulate_crash_mac.cc
+++ b/third_party/crashpad/crashpad/client/simulate_crash_mac.cc
@@ -95,6 +95,11 @@ bool DeliverException(thread_t thread,
       state_count = cpu_context.tsh.count;
       break;
 #endif
+#elif defined(ARCH_CPU_ARM64)
+    case ARM_THREAD_STATE64:
+      state = reinterpret_cast<ConstThreadState>(&cpu_context.ts_64);
+      state_count = cpu_context.ash.count;
+      break;
 #else
 #error Port to your CPU architecture
 #endif
diff --git a/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc b/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc
index c2f4c20496ab59036f2e9c323506a8367cd1b0c0..8e9c5d42913f97a9aad5bdd24098c68bd04f5ee4 100644
--- a/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc
+++ b/third_party/crashpad/crashpad/client/simulate_crash_mac_test.cc
@@ -200,6 +200,27 @@ class TestSimulateCrashMac final : public MachMultiprocess,
         case x86_DEBUG_STATE64:
           EXPECT_EQ(old_state_count, x86_DEBUG_STATE64_COUNT);
           break;
+#elif defined(ARCH_CPU_ARM64)
+        case ARM_UNIFIED_THREAD_STATE: {
+            EXPECT_EQ(old_state_count, ARM_UNIFIED_THREAD_STATE_COUNT);
+            const arm_unified_thread_state* state =
+                reinterpret_cast<const arm_unified_thread_state*>(old_state);
+            switch (state->ash.flavor) {
+              case ARM_THREAD_STATE32:
+                EXPECT_EQ(implicit_cast<uint32_t>(state->ash.count),
+                          implicit_cast<uint32_t>(ARM_THREAD_STATE32_COUNT));
+                break;
+              case ARM_THREAD_STATE64:
+                EXPECT_EQ(implicit_cast<uint32_t>(state->ash.count),
+                          implicit_cast<uint32_t>(ARM_THREAD_STATE64_COUNT));
+                break;
+              default:
+                ADD_FAILURE() << "unexpected ash.flavor " << state->ash.flavor;
+                break;
+            }
+            break;
+        }
+        // FIXME: Check other flavors.
 #else
 #error Port to your CPU architecture
 #endif
@@ -338,6 +359,9 @@ TEST(SimulateCrash, SimulateCrash) {
       x86_FLOAT_STATE64,
       x86_DEBUG_STATE64,
 #endif
+#elif defined(ARCH_CPU_ARM64)
+      ARM_UNIFIED_THREAD_STATE,
+      // FIXME: Check other flavors.
 #else
 #error Port to your CPU architecture
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h b/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h
index 05c035a1d0d8c241bfc065f4da640dd0dd8e775e..9b7b6a16e92888ab6fcd5f793745a195ecdb1651 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/cpu_context_mac.h
@@ -148,6 +148,17 @@ void InitializeCPUContextARM64(CPUContextARM64* context,
                                const arm_neon_state64_t* arm_neon_state64);
 #endif
 
+#if defined(ARCH_CPU_ARM64) || DOXYGEN
+
+void InitializeCPUContextARM64(CPUContextARM64* context,
+                               thread_state_flavor_t flavor,
+                               ConstThreadState state,
+                               mach_msg_type_number_t state_count,
+                               const arm_thread_state64_t* arm_thread_state64,
+                               const arm_neon_state64_t* arm_neon_state64);
+
+#endif
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc
index 8eefac9f39144d364af5ef9cf461d652f00f5435..49ddc691f0a0ea2fa8befbdd90ed3122ccda202d 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.cc
@@ -28,7 +28,11 @@ namespace internal {
 
 ExceptionSnapshotMac::ExceptionSnapshotMac()
     : ExceptionSnapshot(),
+#if defined(ARCH_CPU_X86_FAMILY)
       context_union_(),
+#elif defined(ARCH_CPU_ARM64)
+      context_arm64_(),
+#endif
       context_(),
       codes_(),
       thread_id_(0),
@@ -187,6 +191,15 @@ bool ExceptionSnapshotMac::Initialize(ProcessReaderMac* process_reader,
        exception_code_0_ == (VM_PROT_READ | VM_PROT_EXECUTE))) {
     code_1_is_exception_address = false;
   }
+#elif defined(ARCH_CPU_ARM64)
+  context_.architecture = kCPUArchitectureARM64;
+  context_.arm64 = &context_arm64_;
+  InitializeCPUContextARM64(context_.arm64,
+                            flavor,
+                            state,
+                            state_count,
+                            &thread->thread_context,
+                            &thread->float_context);
 #endif
 
   if (code_1_is_exception_address) {
diff --git a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h
index 52ef519b44d909e74db16f08f2afa72c0ba12bde..9cdb1bab6b49dd6331f9a70164a4a07175e405f7 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/exception_snapshot_mac.h
@@ -84,6 +84,8 @@ class ExceptionSnapshotMac final : public ExceptionSnapshot {
     CPUContextX86 x86;
     CPUContextX86_64 x86_64;
   } context_union_;
+#elif defined(ARCH_CPU_ARM64)
+  CPUContextARM64 context_arm64_;
 #endif
   CPUContext context_;
   std::vector<uint64_t> codes_;
diff --git a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc
index 8659a141a2ced8c005f385d0399634ff920eb458..73fb8f0499e1965f5d7c6bb60a3182116b628dc6 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_annotations_reader_test.cc
@@ -112,9 +112,7 @@ class TestMachOImageAnnotationsReader final
         break;
 
       case kCrashModuleInitialization:
-        // This crash is triggered by __builtin_trap(), which shows up as
-        // SIGILL.
-        SetExpectedChildTermination(kTerminationSignal, SIGILL);
+        SetExpectedChildTerminationBuiltinTrap();
         break;
 
       case kCrashDyld:
@@ -245,14 +243,12 @@ class TestMachOImageAnnotationsReader final
       if (test_type_ == kCrashDyld) {
         static constexpr char kExpectedAnnotation[] =
             "could not load inserted library";
-        size_t expected_annotation_length = strlen(kExpectedAnnotation);
         bool found = false;
         for (const std::string& annotation : all_annotations_vector) {
           // Look for the expectation as a leading substring, because the actual
           // string will contain the library’s pathname and, on OS X 10.9 and
           // later, a reason.
-          if (annotation.substr(0, expected_annotation_length) ==
-                  kExpectedAnnotation) {
+          if (annotation.find(kExpectedAnnotation) != std::string::npos) {
             found = true;
             break;
           }
diff --git a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc
index 625f8a70dacebce66548958908b92d772385205c..53826bfcff58c36764f24795a504e32456bffecc 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/mach_o_image_reader_test.cc
@@ -68,6 +68,8 @@ using Nlist = struct nlist;
 constexpr int kCPUType = CPU_TYPE_X86_64;
 #elif defined(ARCH_CPU_X86)
 constexpr int kCPUType = CPU_TYPE_X86;
+#elif defined(ARCH_CPU_ARM64)
+constexpr int kCPUType = CPU_TYPE_ARM64;
 #endif
 
 // Verifies that |expect_section| and |actual_section| agree.
diff --git a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc
index 61dc3a1f3ae73a4d59d1df5235cb33fb4c01dbf3..181ca16d7ac956a9d8c0ff341df430f40c622ad7 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.cc
@@ -280,6 +280,15 @@ void ProcessReaderMac::InitializeThreads() {
         Is64Bit() ? x86_DEBUG_STATE64 : x86_DEBUG_STATE32;
     mach_msg_type_number_t debug_state_count =
         Is64Bit() ? x86_DEBUG_STATE64_COUNT : x86_DEBUG_STATE32_COUNT;
+#elif defined(ARCH_CPU_ARM64)
+    const thread_state_flavor_t kThreadStateFlavor = ARM_THREAD_STATE64;
+    mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
+
+    const thread_state_flavor_t kFloatStateFlavor = ARM_NEON_STATE64;
+    mach_msg_type_number_t float_state_count = ARM_NEON_STATE64_COUNT;
+
+    const thread_state_flavor_t kDebugStateFlavor = ARM_DEBUG_STATE64;
+    mach_msg_type_number_t debug_state_count = ARM_DEBUG_STATE64_COUNT;
 #endif
 
     kr = thread_get_state(
@@ -366,6 +375,8 @@ void ProcessReaderMac::InitializeThreads() {
     mach_vm_address_t stack_pointer = Is64Bit()
                                           ? thread.thread_context.t64.__rsp
                                           : thread.thread_context.t32.__esp;
+#elif defined(ARCH_CPU_ARM64)
+    mach_vm_address_t stack_pointer = arm_thread_state64_get_sp(thread.thread_context);
 #endif
 
     thread.stack_region_address =
diff --git a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h
index 9feb8b071fa5507206f0d16581e7e942f6285b48..1dc244576a4ae7e57b1b91df7791c26c7796ab97 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac.h
@@ -55,6 +55,10 @@ class ProcessReaderMac {
       x86_debug_state64_t d64;
       x86_debug_state32_t d32;
     };
+#elif defined(ARCH_CPU_ARM_FAMILY)
+    typedef arm_thread_state64_t ThreadContext;
+    typedef arm_neon_state64_t FloatContext;
+    typedef arm_debug_state64_t DebugContext;
 #endif
 
     Thread();
diff --git a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc
index 2d64ff10a8c7d3d14784be643daa6852888bb5ef..49fa4785cfbef820209c131835fd9456bf2ec00c 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/process_reader_mac_test.cc
@@ -565,6 +565,10 @@ class ScopedOpenCLNoOpKernel {
   }
 
   void SetUp() {
+#if defined(ARCH_CPU_ARM64)
+    // FIXME: Make this test work in ARM64.
+    return;
+#endif
     cl_platform_id platform_id;
     cl_int rv = clGetPlatformIDs(1, &platform_id, nullptr);
     ASSERT_EQ(rv, CL_SUCCESS) << "clGetPlatformIDs";
@@ -640,6 +644,10 @@ class ScopedOpenCLNoOpKernel {
 // OpenCL kernels that run on the CPU do not result in cl_kernels images
 // appearing on that OS version.
 bool ExpectCLKernels() {
+#if defined(ARCH_CPU_ARM64)
+    // FIXME: Make this test work in ARM64.
+    return false;
+#endif
 #if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7
   return true;
 #else
diff --git a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc
index 5410be085ea81fc284c1364ba14499a2caf5d918..3f06ec43ed5556be0efaa816cf75bc1c6f7d1b03 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac.cc
@@ -157,6 +157,8 @@ CPUArchitecture SystemSnapshotMac::GetCPUArchitecture() const {
 #if defined(ARCH_CPU_X86_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureX86_64
                                     : kCPUArchitectureX86;
+#elif defined(ARCH_CPU_ARM64)
+  return kCPUArchitectureARM64;
 #else
 #error port to your architecture
 #endif
@@ -174,6 +176,9 @@ uint32_t SystemSnapshotMac::CPURevision() const {
   uint8_t stepping = CastIntSysctlByName<uint8_t>("machdep.cpu.stepping", 0);
 
   return (family << 16) | (model << 8) | stepping;
+#elif defined(ARCH_CPU_ARM64)
+  // FIXME: Consider exposing SOC details here.
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -187,7 +192,7 @@ uint8_t SystemSnapshotMac::CPUCount() const {
 std::string SystemSnapshotMac::CPUVendor() const {
   INITIALIZATION_STATE_DCHECK_VALID(initialized_);
 
-#if defined(ARCH_CPU_X86_FAMILY)
+#if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM64)
   return ReadStringSysctlByName("machdep.cpu.vendor");
 #else
 #error port to your architecture
@@ -207,7 +212,7 @@ uint32_t SystemSnapshotMac::CPUX86Signature() const {
 #if defined(ARCH_CPU_X86_FAMILY)
   return ReadIntSysctlByName<uint32_t>("machdep.cpu.signature", 0);
 #else
-  NOTREACHED();
+  DCHECK(false);
   return 0;
 #endif
 }
@@ -218,7 +223,7 @@ uint64_t SystemSnapshotMac::CPUX86Features() const {
 #if defined(ARCH_CPU_X86_FAMILY)
   return ReadIntSysctlByName<uint64_t>("machdep.cpu.feature_bits", 0);
 #else
-  NOTREACHED();
+  DCHECK(false);
   return 0;
 #endif
 }
@@ -229,7 +234,7 @@ uint64_t SystemSnapshotMac::CPUX86ExtendedFeatures() const {
 #if defined(ARCH_CPU_X86_FAMILY)
   return ReadIntSysctlByName<uint64_t>("machdep.cpu.extfeature_bits", 0);
 #else
-  NOTREACHED();
+  DCHECK(false);
   return 0;
 #endif
 }
@@ -254,7 +259,7 @@ uint32_t SystemSnapshotMac::CPUX86Leaf7Features() const {
   CallCPUID(7, &eax, &ebx, &ecx, &edx);
   return ebx;
 #else
-  NOTREACHED();
+  DCHECK(false);
   return 0;
 #endif
 }
@@ -293,7 +298,7 @@ bool SystemSnapshotMac::CPUX86SupportsDAZ() const {
   // Test the DAZ bit.
   return fxsave.mxcsr_mask & (1 << 6);
 #else
-  NOTREACHED();
+  DCHECK(false);
   return false;
 #endif
 }
diff --git a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc
index 2b665924d5ea08fe2714de06f3b766d731bc39e8..2c1a322bc08b522d9a3cf95bcf2510806484d767 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/system_snapshot_mac_test.cc
@@ -69,6 +69,8 @@ TEST_F(SystemSnapshotMacTest, GetCPUArchitecture) {
   EXPECT_EQ(cpu_architecture, kCPUArchitectureX86);
 #elif defined(ARCH_CPU_X86_64)
   EXPECT_EQ(cpu_architecture, kCPUArchitectureX86_64);
+#elif defined(ARCH_CPU_ARM64)
+  EXPECT_EQ(cpu_architecture, kCPUArchitectureARM64);
 #else
 #error port to your architecture
 #endif
@@ -87,6 +89,8 @@ TEST_F(SystemSnapshotMacTest, CPUVendor) {
   if (cpu_vendor != "GenuineIntel" && cpu_vendor != "AuthenticAMD") {
     FAIL() << "cpu_vendor " << cpu_vendor;
   }
+#elif defined(ARCH_CPU_ARM64)
+  EXPECT_EQ(cpu_vendor, "");
 #else
 #error port to your architecture
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc
index ddb4def4514236753430c14b2f55adf4ee370b8a..f2f9bb83bafd9b1837f09bae1d7b869a2bec3259 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc
+++ b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.cc
@@ -23,7 +23,11 @@ namespace internal {
 
 ThreadSnapshotMac::ThreadSnapshotMac()
     : ThreadSnapshot(),
+#if defined(ARCH_CPU_X86_FAMILY)
       context_union_(),
+#elif defined(ARCH_CPU_ARM64)
+      context_arm64_(),
+#endif
       context_(),
       stack_(),
       thread_id_(0),
@@ -75,6 +79,15 @@ bool ThreadSnapshotMac::Initialize(
                             &process_reader_thread.float_context.f32,
                             &process_reader_thread.debug_context.d32);
   }
+#elif defined(ARCH_CPU_ARM64)
+  context_.architecture = kCPUArchitectureARM64;
+  context_.arm64 = &context_arm64_;
+  InitializeCPUContextARM64(context_.arm64,
+                            THREAD_STATE_NONE,
+                            nullptr,
+                            0,
+                            &process_reader_thread.thread_context,
+                            &process_reader_thread.float_context);
 #endif
 
   INITIALIZATION_STATE_SET_VALID(initialized_);
diff --git a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h
index 946b0085c1a30af352a4f60bae3e71a6967edb61..eb06e3e28ad5f317cb374f49b1149fe983b71a93 100644
--- a/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h
+++ b/third_party/crashpad/crashpad/snapshot/mac/thread_snapshot_mac.h
@@ -68,6 +68,8 @@ class ThreadSnapshotMac final : public ThreadSnapshot {
     CPUContextX86 x86;
     CPUContextX86_64 x86_64;
   } context_union_;
+#elif defined(ARCH_CPU_ARM64)
+  CPUContextARM64 context_arm64_;
 #endif
   CPUContext context_;
   MemorySnapshotGeneric stack_;
diff --git a/third_party/crashpad/crashpad/util/mac/mac_util_test.mm b/third_party/crashpad/crashpad/util/mac/mac_util_test.mm
index 546c6286964ee0e3a9c9ed7ecd443ebf9c7759e1..06bf47c3af9b3aba8c6485cf8c1f76b61e410db9 100644
--- a/third_party/crashpad/crashpad/util/mac/mac_util_test.mm
+++ b/third_party/crashpad/crashpad/util/mac/mac_util_test.mm
@@ -135,7 +135,9 @@ TEST(MacUtil, MacModelAndBoard) {
   MacModelAndBoard(&model, &board);
 
   EXPECT_FALSE(model.empty());
+#if !defined(ARCH_CPU_ARM64)
   EXPECT_FALSE(board.empty());
+#endif
 }
 
 }  // namespace
diff --git a/third_party/crashpad/crashpad/util/mac/service_management_test.mm b/third_party/crashpad/crashpad/util/mac/service_management_test.mm
index 0bec3366f9094b9b42f12ddf1bf6d4134a7f9b20..374f6ddf7a62d768efb587c4828db61037beca56 100644
--- a/third_party/crashpad/crashpad/util/mac/service_management_test.mm
+++ b/third_party/crashpad/crashpad/util/mac/service_management_test.mm
@@ -48,7 +48,7 @@ void ExpectProcessIsRunning(pid_t pid, std::string& last_arg) {
     // If the process is in the middle of calling exec, process_info.Arguments()
     // may fail. Loop with a small retry delay while waiting for the expected
     // successful call.
-    int inner_tries = 10;
+    int inner_tries = 30;
     bool success;
     do {
       success = process_info.Arguments(&job_argv);
diff --git a/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc b/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc
index 553661e3cb9e8a546675a51a883783cd1e716ab4..572f964e93fa9ce1559c7b7d42cdc88b506e525e 100644
--- a/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/exc_server_variants_test.cc
@@ -975,8 +975,7 @@ class TestExcServerVariants : public MachMultiprocess,
         flavor_(flavor),
         state_count_(state_count),
         handled_(false) {
-    // This is how the __builtin_trap() in MachMultiprocessChild() appears.
-    SetExpectedChildTermination(kTerminationSignal, SIGILL);
+    SetExpectedChildTerminationBuiltinTrap();
   }
 
   // UniversalMachExcServer::Interface:
@@ -1180,6 +1179,10 @@ TEST(ExcServerVariants, ThreadStates) {
       {x86_THREAD_STATE, x86_THREAD_STATE_COUNT},
       {x86_FLOAT_STATE, x86_FLOAT_STATE_COUNT},
       {x86_EXCEPTION_STATE, x86_EXCEPTION_STATE_COUNT},
+#elif defined(ARCH_CPU_ARM64)
+      {ARM_THREAD_STATE64, ARM_THREAD_STATE64_COUNT},
+      {ARM_NEON_STATE64, ARM_NEON_STATE64_COUNT},
+      {ARM_EXCEPTION_STATE64, ARM_EXCEPTION_STATE64_COUNT},
 #else
 #error Port this test to your CPU architecture.
 #endif
diff --git a/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc b/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc
index 6dbc04ed170cdef710702adce346a8e930e0772c..ebcb4b6bd4d2efee9179f44ba56ddf1748453855 100644
--- a/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/exception_ports_test.cc
@@ -145,8 +145,7 @@ class TestExceptionPorts : public MachMultiprocess,
         who_crashes_(who_crashes),
         handled_(false) {
     if (who_crashes_ != kNobodyCrashes) {
-      // This is how the __builtin_trap() in Child::Crash() appears.
-      SetExpectedChildTermination(kTerminationSignal, SIGILL);
+      SetExpectedChildTerminationBuiltinTrap();
     }
   }
 
@@ -205,8 +204,14 @@ class TestExceptionPorts : public MachMultiprocess,
       int signal;
       ExcCrashRecoverOriginalException(code[0], nullptr, &signal);
 
-      // The child crashed with __builtin_trap(), which shows up as SIGILL.
+      // The child crashed with __builtin_trap(), which shows up as...
+#if defined(ARCH_CPU_ARM64)
+      // ...SIGTRAP.
+      EXPECT_EQ(signal, SIGTRAP);
+#else
+      // ...SIGILL.
       EXPECT_EQ(signal, SIGILL);
+#endif
     }
 
     EXPECT_EQ(AuditPIDFromMachMessageTrailer(trailer), 0);
diff --git a/third_party/crashpad/crashpad/util/mach/exception_types_test.cc b/third_party/crashpad/crashpad/util/mach/exception_types_test.cc
index da2c82223022b295b999d1195a5d0de9d8979128..d740491429d8cde3fe206def105e834a98065f8f 100644
--- a/third_party/crashpad/crashpad/util/mach/exception_types_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/exception_types_test.cc
@@ -41,8 +41,11 @@ TEST(ExceptionTypes, ExcCrashRecoverOriginalException) {
       {0xb100002, EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE, SIGSEGV},
       {0xa100002, EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE, SIGBUS},
       {0xa100005, EXC_BAD_ACCESS, VM_PROT_READ | VM_PROT_EXECUTE, SIGBUS},
+#if defined(ARCH_CPU_X86_FAMILY)
       {0xa10000d, EXC_BAD_ACCESS, EXC_I386_GPFLT, SIGBUS},
+#endif
       {0x9100032, EXC_BAD_ACCESS, KERN_CODESIGN_ERROR, SIGKILL},
+#if defined(ARCH_CPU_X86_FAMILY)
       {0x4200001, EXC_BAD_INSTRUCTION, EXC_I386_INVOP, SIGILL},
       {0x420000b, EXC_BAD_INSTRUCTION, EXC_I386_SEGNPFLT, SIGILL},
       {0x420000c, EXC_BAD_INSTRUCTION, EXC_I386_STKFLT, SIGILL},
@@ -53,6 +56,7 @@ TEST(ExceptionTypes, ExcCrashRecoverOriginalException) {
       {0x5500007, EXC_SOFTWARE, EXC_I386_BOUND, SIGTRAP},
       {0x5600001, EXC_BREAKPOINT, EXC_I386_SGL, SIGTRAP},
       {0x5600002, EXC_BREAKPOINT, EXC_I386_BPT, SIGTRAP},
+#endif
       {0x0700080, EXC_SYSCALL, 128, 0},
       {0x0706000, EXC_SYSCALL, 0x6000, 0},
       {0x3000000, 0, 0, SIGQUIT},
@@ -142,8 +146,11 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC(EXC_BAD_ACCESS, KERN_INVALID_ADDRESS),
       ENCODE_EXC(EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE),
       ENCODE_EXC(EXC_BAD_ACCESS, VM_PROT_READ | VM_PROT_EXECUTE),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC(EXC_BAD_ACCESS, EXC_I386_GPFLT),
+#endif
       ENCODE_EXC(EXC_BAD_ACCESS, KERN_CODESIGN_ERROR),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC(EXC_BAD_INSTRUCTION, EXC_I386_INVOP),
       ENCODE_EXC(EXC_BAD_INSTRUCTION, EXC_I386_SEGNPFLT),
       ENCODE_EXC(EXC_BAD_INSTRUCTION, EXC_I386_STKFLT),
@@ -154,6 +161,7 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC(EXC_SOFTWARE, EXC_I386_BOUND),
       ENCODE_EXC(EXC_BREAKPOINT, EXC_I386_SGL),
       ENCODE_EXC(EXC_BREAKPOINT, EXC_I386_BPT),
+#endif
       ENCODE_EXC(EXC_SYSCALL, 128),
       ENCODE_EXC(EXC_SYSCALL, 0x6000),
 #undef ENCODE_EXC
@@ -166,8 +174,11 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, KERN_INVALID_ADDRESS),
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, KERN_PROTECTION_FAILURE),
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, VM_PROT_READ | VM_PROT_EXECUTE),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, EXC_I386_GPFLT),
+#endif
       ENCODE_EXC_CRASH(EXC_BAD_ACCESS, KERN_CODESIGN_ERROR),
+#if defined(ARCH_CPU_X86_FAMILY)
       ENCODE_EXC_CRASH(EXC_BAD_INSTRUCTION, EXC_I386_INVOP),
       ENCODE_EXC_CRASH(EXC_BAD_INSTRUCTION, EXC_I386_SEGNPFLT),
       ENCODE_EXC_CRASH(EXC_BAD_INSTRUCTION, EXC_I386_STKFLT),
@@ -178,6 +189,7 @@ TEST(ExceptionTypes, ExceptionCodeForMetrics) {
       ENCODE_EXC_CRASH(EXC_SOFTWARE, EXC_I386_BOUND),
       ENCODE_EXC_CRASH(EXC_BREAKPOINT, EXC_I386_SGL),
       ENCODE_EXC_CRASH(EXC_BREAKPOINT, EXC_I386_BPT),
+#endif
       ENCODE_EXC_CRASH(EXC_SYSCALL, 128),
       ENCODE_EXC_CRASH(EXC_SYSCALL, 0x6000),
 #undef ENCODE_EXC_CRASH
diff --git a/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc b/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc
index e3a3f94bd0ff294cdfde8244bb484ea729279e43..a7198da8a166777ab2e120d8e474dc27dff60837 100644
--- a/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc
+++ b/third_party/crashpad/crashpad/util/mach/mach_message_server_test.cc
@@ -309,7 +309,7 @@ class TestMachMessageServer : public MachMessageServer::Interface,
   // ensure that whatever buffer was allocated to receive a RequestMessage is
   // not large enough to receive a LargeRequestMessage.
   struct LargeRequestMessage : public RequestMessage {
-    uint8_t data[4 * PAGE_SIZE];
+    uint8_t data[4 * PAGE_MAX_SIZE];
   };
 
   struct ReplyMessage : public mig_reply_error_t {
diff --git a/third_party/crashpad/crashpad/util/mach/mig_gen.py b/third_party/crashpad/crashpad/util/mach/mig_gen.py
index dcbf8296d2adb0a5f6fa3ec0c58c74f79bf12f2d..b63e45a43dccfaf83b7c6df8098e382281f58780 100755
--- a/third_party/crashpad/crashpad/util/mach/mig_gen.py
+++ b/third_party/crashpad/crashpad/util/mach/mig_gen.py
@@ -23,7 +23,6 @@ import sys
 MigInterface = collections.namedtuple(
     'MigInterface', ['user_c', 'server_c', 'user_h', 'server_h'])
 
-
 def generate_interface(defs,
                        interface,
                        includes=[],
@@ -53,6 +52,8 @@ def generate_interface(defs,
         command.extend(['-arch', arch])
     if sdk is not None:
         command.extend(['-isysroot', sdk])
+    if arch is not None:
+        command.extend(['-arch', arch])
     for include in includes:
         command.extend(['-I' + include])
     command.append(defs)
@@ -86,6 +87,5 @@ def main(args):
                        parsed.clang_path, parsed.mig_path, parsed.migcom_path,
                        parsed.arch)
 
-
 if __name__ == '__main__':
     sys.exit(main(sys.argv[1:]))
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_mac.S b/third_party/crashpad/crashpad/util/misc/capture_context_mac.S
index f6acafbd3380e6de0e6cf17516913f922793dc4b..66afce49986b471a4d81e5b57c914650174ce21b 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_mac.S
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_mac.S
@@ -285,4 +285,56 @@ CAPTURECONTEXT_SYMBOL:
 
 .subsections_via_symbols
 
+#elif defined(__arm64__)
+
+// namespace crashpad {
+// void CaptureContext(arm_unified_thread_state_t* arm_thread_state);
+// }  // namespace crashpad
+#define CAPTURECONTEXT_SYMBOL __ZN8crashpad14CaptureContextEP24arm_unified_thread_state
+
+  .section __TEXT,__text,regular,pure_instructions
+  .private_extern CAPTURECONTEXT_SYMBOL
+  .globl CAPTURECONTEXT_SYMBOL
+  .balign 4, 0x0
+CAPTURECONTEXT_SYMBOL:
+
+  .cfi_startproc
+
+  stp x0, x1, [x0, #0x08]
+  stp x2, x3, [x0, #0x18]
+  stp x4, x5, [x0, #0x28]
+  stp x6, x7, [x0, #0x38]
+  stp x8, x9, [x0, #0x48]
+  stp x10, x11, [x0, #0x58]
+  stp x12, x13, [x0, #0x68]
+  stp x14, x15, [x0, #0x78]
+  stp x16, x17, [x0, #0x88]
+  stp x18, x19, [x0, #0x98]
+  stp x20, x21, [x0, #0xa8]
+  stp x22, x23, [x0, #0xb8]
+  stp x24, x25, [x0, #0xc8]
+  stp x26, x27, [x0, #0xd8]
+  stp x28, x29, [x0, #0xe8]
+  str x30, [x0, #0xf8]
+
+  mov x1, sp
+  str x1, [x0, #0x100]
+
+  str x30, [x0, #0x108]
+
+  mrs x1, NZCV
+  str x1, [x0, #0x110]
+
+  mov w1, #0x06 // ARM_THREAD_STATE64
+  str w1, [x0]
+
+  mov w1, #0x46 // ARM_THREAD_STATE64_COUNT
+  str w1, [x0, #0x04]
+
+  ldr x1, [x0, #0x10]
+
+  ret
+
+  .cfi_endproc
+
 #endif
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_mac.mm b/third_party/crashpad/crashpad/util/net/http_transport_mac.mm
index a433bb357da5865144ade7d3663b1c9b36199f8e..8faa1b8a0444f903bf588ba085d60882e9d61162 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_mac.mm
+++ b/third_party/crashpad/crashpad/util/net/http_transport_mac.mm
@@ -91,6 +91,8 @@ NSString* UserAgentString() {
     NSString* arch = @"i386";
 #elif defined(ARCH_CPU_X86_64)
     NSString* arch = @"x86_64";
+#elif defined(ARCH_CPU_ARM64)
+    NSString* arch = @"arm64";
 #else
 #error Port
 #endif
diff --git a/third_party/crashpad/crashpad/util/posix/signals.cc b/third_party/crashpad/crashpad/util/posix/signals.cc
index 7dbe10ebc224d02e20cce6dd45e2e6ed3f45c213..694203a85c5d4b58445234ec0b25634a97f898ff 100644
--- a/third_party/crashpad/crashpad/util/posix/signals.cc
+++ b/third_party/crashpad/crashpad/util/posix/signals.cc
@@ -208,6 +208,12 @@ bool Signals::WillSignalReraiseAutonomously(const siginfo_t* siginfo) {
   const int sig = siginfo->si_signo;
   const int code = siginfo->si_code;
 
+#if defined(OS_MACOSX) && defined(ARCH_CPU_ARM64)
+  if ((sig == SIGILL && code == ILL_ILLTRP) || (sig == SIGSEGV && code == SEGV_ACCERR)) {
+    return false;
+  }
+#endif
+
   // Only these signals can be generated from hardware faults and can re-raise
   // autonomously.
   return (sig == SIGBUS ||
diff --git a/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc b/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc
index d801bb149fed2e4874190ae4eda7684841997636..6cb6fae0b8e1e8db6de36c66c9866c0ca2d6b232 100644
--- a/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc
+++ b/third_party/crashpad/crashpad/util/process/process_memory_mac_test.cc
@@ -33,7 +33,7 @@ namespace {
 
 TEST(ProcessMemoryMac, ReadMappedSelf) {
   vm_address_t address = 0;
-  constexpr vm_size_t kSize = 4 * PAGE_SIZE;
+  const vm_size_t kSize = 4 * PAGE_SIZE;
   kern_return_t kr =
       vm_allocate(mach_task_self(), &address, kSize, VM_FLAGS_ANYWHERE);
   ASSERT_EQ(kr, KERN_SUCCESS) << MachErrorMessage(kr, "vm_allocate");
@@ -88,7 +88,7 @@ TEST(ProcessMemoryMac, ReadMappedSelf) {
 
 TEST(ProcessMemoryMac, ReadSelfUnmapped) {
   vm_address_t address = 0;
-  constexpr vm_size_t kSize = 2 * PAGE_SIZE;
+  const vm_size_t kSize = 2 * PAGE_SIZE;
   kern_return_t kr =
       vm_allocate(mach_task_self(), &address, kSize, VM_FLAGS_ANYWHERE);
   ASSERT_EQ(kr, KERN_SUCCESS) << MachErrorMessage(kr, "vm_allocate");
@@ -150,7 +150,7 @@ TEST(ProcessMemoryMac, ReadSelfUnmapped) {
 
 TEST(ProcessMemoryMac, ReadCStringSelfUnmapped) {
   vm_address_t address = 0;
-  constexpr vm_size_t kSize = 2 * PAGE_SIZE;
+  const vm_size_t kSize = 2 * PAGE_SIZE;
   kern_return_t kr =
       vm_allocate(mach_task_self(), &address, kSize, VM_FLAGS_ANYWHERE);
   ASSERT_EQ(kr, KERN_SUCCESS) << MachErrorMessage(kr, "vm_allocate");
@@ -259,7 +259,7 @@ TEST(ProcessMemoryMac, MappedMemoryDeallocates) {
   // This is the same but with a big buffer that’s definitely larger than a
   // single page. This makes sure that the whole mapped region winds up being
   // deallocated.
-  constexpr size_t kBigSize = 4 * PAGE_SIZE;
+  const size_t kBigSize = 4 * PAGE_SIZE;
   std::unique_ptr<char[]> big_buffer(new char[kBigSize]);
   test_address = FromPointerCast<mach_vm_address_t>(&big_buffer[0]);
   ASSERT_TRUE((mapped = memory.ReadMapped(test_address, kBigSize)));
